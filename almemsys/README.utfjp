/* 
* 以下関数群は動的なメモリーの割り当てを前提にした、c言語のための標準的文字列操作の関数です。
* 私が自分のプログラミングの為に書きました。
* どなたでもご利用になれますし、書き換えも構いません。
* この関数は私 Masashi Shimakuraが20051123に書きました、現在でもメンテナンスを行ってます。
* 何かお気づきの点がありましたら以下にご連絡ください。
* 
*     mail: masashi@ms-n.com
*
*/

このFILEは almemsys.so ライブラリに含まれる以下の関数の使いかたを説明しています。

   (以下は動的アロケーションの関数)
   SAFE_FPCAT() ファイルポインターから一行読み込む
   SAFE_FDCPM() ファイルディスクリプターから一行読み込む
   SAFE_FDCAT() ファイルディスクリプターから改行まで読み込む
   SAFE_FILEFDCAT() ファイルディスクリプターからストリーム終端まで読み込む
   SAFE_MEMCPY() バッファーに任意のサイズの文字列をコピーする
   SAFE_STRNCAT() 既に使われているバッファーの後ろに文字列を追加する
   SAFE_SPRINTF() フォーマット文字列をバッファーにコピーする
   DELIM_GET() デリミターで区切られたデータの指定番めを取り出す
   ALGET_READ() fdから得たデータをネゴしながら行単位で受け取りファイルに書き出す関数。
   ALGET_WRITE()  FPから一行ずつ読み出したデータをネゴしながら一定量小分けでsendする関数
   SWAP_RN() 文字列全体の中のすべての指定文字を、(\r\n)の改行に置き換える。 
   NULL_FREE() バッファーの使用された大きさ分だけNULLで埋める。

   (以下は通常の関数)
   SELF_MEMCPY() 指定サイズを越えないメモリーコピー
   SELF_STRNCAT() 指定サイズを越えないでバッファーの後端に文字列を追加する
   SELF_MEMCMP() お互いの大きさも考慮した文字列の比較
   SELF_DELIM_GET() デリミターで区切られたデータの指定番めを取り出す、動的なバッファーを使わない

   (以下はソケット関数)
   SOCKET_READS() ファイルディスクリプタから動的なバッファに読み込む  
   SOCKET_READA() ファイルディスクリプタから動的なバッファに読み込む  
   SOCKET_READAS() ファイルディスクリプタから動的なバッファに読み込む (select付き)  
   SOCKET_SENDS() ファイルディスクリプタに書き込む 1 (select)
   SOCKET_SEND() ファイルディスクリプタに書き込む 2
   SELECT_FDCAT() ファイルディスクリプタから読み込む

   (以下はFILE操作関数)
   FILE_COPY() ファイルのコピー
   UNLINKDIR() ディレクトリー内のファイルの一括削除

   (以下は時間関係の関数)
   CHAR_WDAY() 0から6の数字から3文字の曜日を示す文字列をかえす。
   CHAR_MON()  0から11の数字から3文字の月を示す文字列をかえす。
   UTIME_GETR() unix time からcharで指定した時間をかえす
   CTIME_GETR() 現在時刻の指定文字の示す時間属性をかえす */
   TIME_MINUS() char 単位で t 時 から mt 時間引いた時間を返す関数 (0 - 1 = 23)
   MONTH_LAST() 何年何月の最後の日を出す
   DAY_MINUS()  現在の年月で、一日前の日をかえす。(1 - 1 = 31)
   GET_UNIXTIME() localな時間からUNIX時間をかえす。
   MESSAGE_ID() 出きるだけユニークなメッセージIDを作ります。


   (以下は低水準な関数)
   CH_INT() 文字列が数字か+,-で構成されていることを確認
   CH_INT2() 文字列が数字で構成されていることを確認
   CH_INT3() 文字列が数字か任意の文字一つで構成されていることを確認
   CH_INT_V6() dataがIPV6アドレスを構成する文字であることを確認
   CH_INT_V4() dataがIPV4アドレスを構成する文字であることを確認
   CH_CHAR() 文字列が数字かASCII文字であることを確認し、バッファーにコピーする。
   CHAR_COUNT() 文字列に検索するキャラクタが幾つ含まれるか数える
   CHAR_GET() 文字列をデリミターで区切り、指定番めの文字列をバッファに入れる。
   CHAR_POINT() 文字列の中で指定文字が指定番めに表れる先頭からの位置を返す。
   CLEAN_MEM() 文字列を指定した文字で全て書き換える。
   COUNT_MEMCPY() 文字列の先頭から指定した数だけバッファにコピーする
   COUNT_MEMCPY2() 文字列の指定位置から指定した数だけバッファにコピーする
   DELIM_COUNT() 文字列をデリミターで区切り、指定番めの文字列の先頭位置と終端位置を返す
   MEM_COUNT() 文字列に指定文字が最後に表れる場所（番め）を返す。
   MEM_TCOUNT() 文字列に指定文字が最初に表れる場所（番め）を返す。
   MEMCOUNT_CPM() 文字列の指定位置を別バッファにコピーする
   RM_CRLF() 文字列の中の\r\nを0x00に置き換える
   RM_CHAR() 文字列の中の特定の文字を消して、お尻をつめる。
   SET_MEM() 文字列の中の特定の文字を0x00に置き換える
   SWAP_MEM() 特定の文字を特定の文字で置き換える
   CHMEM() とにかく指定した数だけ0x00でうめる。


   (以下は特殊用途関数)
   BASE64() 文字列をbase64エンコードする。
   UJTOJ() EUC文字列をJISに変更する。
   SAFE_BASE64() 文字列をbase64エンコードする。(動的バッファ)
   SAFE_UJTOJ() EUC文字列をJISに変更する。（動的バッファ）
   MIME_UJTOJ() EUC文字列をJISに変換しながら、76文字で折り返しMIMEに従ったsubject文字に変更する。（動的バッファ）
   RANDDATA() 指定した数字の幅の中から、マイクロ秒をseedとして生成した乱数を返す。


   (以下は時間関係の関数リファレンス)
   CHAR_WDAY() 0から6の数字から3文字の曜日を示す文字列をかえす。
   CHAR_MON()  0から11の数字から3文字の月を示す文字列をかえす。
   UTIME_GETR() unix time からcharで指定した時間をかえす
   CTIME_GETR() 現在時刻の指定文字の示す時間属性をかえす 
   TIME_MINUS() cha 単位で t 時 から mt 時間引いた時間を返す関数 0 - 1 = 23
   GET_UNIXTIME() localな時間からUNIX時間をかえす。
   DAY_MINUS()  現在の年月で、一日前の日をかえす。(1 - 1 = 31)
   MONTH_LAST() 何年何月の最後の日を出す
   MONTH_MINUS()  指定月から一ヶ月引いた月をかえす。単純。。
   TIME_GETR() 現在時刻の:区切りの文字列をバッファにかえす。







      
   ----- 以下は動的アロケーション関数リファレンス -----




名前
   SAFE_FPCAT() ファイルポインターから一行読み込む

書式
   char * safe_fpcat(FILE *(1), char *(2), int *(3), int(4));
   (1) ファイルポインター
   (2) char * すでにmalloc()で確保されたバッファーを指定（通常戻り値も同じになる）
   (3) 終了ステータス(int ポインター) 、異常は(-1)を返す。
   (4) int 確保するバッファーの上限

   使用例   >   data = safe_fpcat(fp, data, &stat, MAX_LEN);

説明
   ファイルポインターから一行バッファーに読み込み終了する関数。(動的バッファー)
   得られるバッファーの後端に改行を含まない。
   バッファーのアドレスは変化するので戻り値(char *)を信用すること、通常の使用では(2)
   と戻り値の変数は同じになる。

返り値
   動的にサイズを調整(mallc)したバッファのアドレスを返す。失敗した場合はNULLを返す。





名前
   SAFE_FDCPM() ファイルディスクリプターから一行読み込む

書式
   char * safe_fdcpm(int(1), char *(2), int *stat(3), int(4));
   (1) int ファイルディスクプリター
   (2) char * すでにmalloc()で確保されたバッファーを指定（通常戻り値も同じになる）
   (3) 終了ステータス(intポインター) 、異常は(-1)を返す。
   (4) int 確保するバッファーの上限

   使用例   >   data = safe_fdcpm(fd, data,  &stat, MAX_LEN);

説明
   ファイルディスクプリターから改行まで読み込み終了する関数。(動的バッファー)
   得られるバッファーの後端に改行を含む。
   但し閾値を超えた場合はバッファーの後端に改行を含まないので、含まない場合はエラー
   とするか再度読むように使うこと。 バッファーのアドレスは変化するので戻り値(char *)
   を信用すること、通常の使用では(2)と戻り値の変数は同じになる。

返り値
   動的にサイズを調整(mallc)したバッファのアドレスを返す。失敗した場合はNULLを返す。






名前
   SAFE_FDCAT() ファイルディスクリプターから改行まで読み込む

書式
   char * safe_fdcat(int(1), char *(2), int *stat(3), int(4), int(5));
   (1) int ファイルディスクプリター
   (2) char * すでにmalloc()で確保されたバッファーを指定（通常戻り値も同じになる）
   (3) 終了ステータス(ポインター) 、異常は(-1)を返す。
   (4) int 確保するバッファーの上限。
   (5) int select()にてタイムアウトを見る際の時間(sec)

   使用例   >   data = safe_fdcat(fd, data, &stat, MAX_LEN, time);

説明
   ファイルディスクプリターから改行まで読み込み終了する関数。(動的バッファー)
   得られるバッファーの後端に改行を含む。 但し閾値を超えた場合は改行のみを書き込
   む。この場合得られるデータは改行のみとなる。問題のおきた場合のステータスは常に
   -1 で、正常な場合は得たバイト数を返す。0の場合は正常である。

返り値
   動的にサイズを調整(mallc)したバッファのアドレスを返す。失敗した場合はNULLを返す。






名前
   SAFE_FILEFDCAT() ファイルディスクリプターからストリーム終端まで読み込む

書式
   char * safe_filefdcat(int(1), char *(2), int *stat(3), int(4), int(5));
   (1) int ファイルディスクプリター
   (2) char * すでにmalloc()で確保されたバッファーを指定（通常戻り値も同じになる）
   (3) 終了ステータス(ポインター) 、異常は(-1)を返す。
   (4) int 確保するバッファーの上限。
   (5) int select()にてタイムアウトを見る際の時間(sec)

   使用例   >   data = safe_filefdcat(fd, data, indata, &stat, MAX_LEN);

説明
   ファイルディスクプリターからストリームの終端まで読み込み終了する関数。(動的バッファー)
   得られるバッファーの後端に改行を含む。 但し閾値を超えた場合はバッファーの後端に改行を
   書き込み、それ以後改行が読まれるまでfdを空読みする。 EOF(End of file)が読まれるまで
   ループを抜けない点に注意。 バッファーのアドレスは変化するので戻り値(char *)を信用する
   こと、通常の使用では(2)と戻り値の変数は同じになる。

返り値
   動的にサイズを調整(mallc)したバッファのアドレスを返す。失敗した場合はNULLを返す。





名前
   SAFE_MEMCPY() バッファーに任意のサイズの文字列をコピーする

書式
   char * safe_memcpy(char *(1), char *(2), int(3));
   (1) char * char * すでにmalloc()で確保されたバッファーを指定（通常戻り値も同じになる）
   (2) char * 読み込むバッファー。
   (3) int 確保するバッファーの上限

   使用例   >   data = safe_memcpy(data, indata, MAX_LEN);

説明
   バッファーからバッファーにデータをコピーする関数。(動的バッファー)

返り値
   動的にサイズを調整(mallc)したバッファのアドレスを返す。失敗した場合はNULLを返す。






名前
   SAFE_STRNCAT() 既に使われているバッファーの後ろに文字列を追加する

書式
   char * safe_strncat(char *(1), char *(2), int(3));
   (1) char * すでにmalloc()で確保されたバッファーを指定（通常戻り値も同じになる）
   (2) char * 読み込むバッファー。
   (3) int 確保するバッファーの上限

   使用例   >   data = safe_strncat(data, indata, MAX_LEN);

説明
   すでにあるバッファーの大きさを変更して、すでに入っているデータの後ろにデータを追加
   する関数。(動的バッファー)

返り値
   動的にサイズを調整(mallc)したバッファのアドレスを返す。失敗した場合はNULLを返す。






名前
   SAFE_SPRINTF() フォーマット文字列をバッファーにコピーする

書式
   char * safe_sprintf(char *(1), int(4), const char *(2), format, ...);
   (1) char * すでにmalloc()で確保されたバッファーを指定（通常戻り値も同じになる）
   (2) フォーマット文字列 " taro %d?n"
   (3) フォーマット用変数、データ(数は10個まで)
   (4) int 確保するバッファーの上限

   使用例   >   data = safe_sprintf(data, MAX_LEN, "--%d--?n", inA);

説明
   フォーマット文字列から指定したバッファーにデータを追加する関数。(動的バッファー)
   読み込みバッファーを指定して書き込むことは出来ませんので注意。

返り値
   動的にサイズを調整(mallc)したバッファのアドレスを返す。失敗した場合はNULLを返す。






名前
   DELIM_GET() デリミターで区切られたデータの指定番めを取り出す

書式
   char * delim_get(char *(1), char *(2), char(3), int *(4), int(5));
   (1) char * 元データ
   (2) char * 取り出したデータを入れるバファ
   (3) デリミター
   (4) ステータス、異常は-1
   (4) 何番めかの指定

   使用例      >     data = delim_get(base, data, ',', %stat, 4);

説明
   上の使用例ではbase内をデリミタ(,)で区切った場合の4番めの文字列をdataに
   書き込む。書き込むバッファは予めmalloc()されている必要がある。

帰り値
   失敗した場合は返却文字列に"NOT"を書き込む。
   終端には0x00が入る。












   ----- 以下は通常関数のリファレンス -----




名前
   SELF_MEMCPY() 指定サイズを越えないメモリーコピー

書式
   int self_memcpy(char *(1), char *(2), int(3));
   (1) char * コピー先のバッファ
   (2) char * コピー元のバッファ
   (3) int コピーする文字列の上限、普通は(1)で確保されている上限サイズ

   使用例    >   ret = self_memcpy(data, "ABCD", 128);

説明
   大きさが固定のバッファーに対して、安全にデータをコピーする。

返り値
   つねに0を返す





名前
   SELF_STRNCAT() 指定サイズを越えないでバッファーの後端に文字列を追加する

書式
   int self_strncat(char *(1), char *(2), int(3));
   (1) char * コピー先のバッファ
   (2) char * コピー元のバッファ
   (3) int コピーする文字列の上限、普通は(1)で確保されている上限サイズ

   使用例    >   ret = self_memcpy(data, "ABCD", 128);

説明
   大きさが固定のバッファーに対して、安全にデータを後端にコピーする。

返り値
   つねに0を返す





名前
   SELF_MEMCMP() お互いの大きさも考慮した文字列の比較

書式
   int self_memcmp(char *(1), char *(2));
   (1) char * 比較文字列1
   (2) char * 比較文字列2

   使用例     >   ret = self_memcmp(data1, "taro");

説明
   文字列同士の比較だが、サイズが違う場合もエラーと判断する。

返り値
   通常のmemcmp()と同じだが、サイズが違う場合も-1を返す。






名前
   ALGET_READ() fdから得たデータをネゴしながら行単位で受け取りファイルに書き出す関数。

書式
   char * alget_read(char *(1), int(2), int(3), int(4), int *(5), char(6), int(7), int(8));
   (1) 書き出すファイルのパス名前
   (2) データを置くバファ（意味ないので、いずれなくします）
   (3) ファイルディスクリプター
   (4) 返却ステータスのポインター
   (5) 受け取りデータの特定の文字を置き換えます。（普通は送信時に改行を何に変えているか)
   (6) この数字よりサイズが大きいとデータの受け取りを一時中断しますが、実際の単位は行単位です。
   (7) mode 1 client -> server  最後にステータスを送る
       mode 0 server -> client  受け取って終わり

使用例
   rec = alget_read(filename, rec, sk, interval, &stat, delim, file_len, mode);

返り値
   (2)のポインターを返すが、現状で意味がないので、いずれへんこうします。




名前
   ALGET_WRITE()  FPから一行ずつ読み出したデータをネゴしながら一定量小分けでsendする関数

書式
   int alget_write(int(1), FILE *(2), int(3), char(4), int(5), int(6));
   (1) ファイルディスクリプター
   (2) 書き出すファイルのファイルポインター
   (3) select()の待ち時間(秒)
   (4) 送信データの特定の文字を置き換えます。（普通は送信時に改行を何に変えるか)
   (5) この数字よりサイズが大きいとデータの受け取りを一時中断しますが、実際の単位は行単位です。
   (6) mode 1 client -> server  最後にステータスを送る
       mode 0 server -> client  受け取って終わり

使用例
   ren = alget_write(int sock_fd, FILE * fp, int interval, char delim, int file_len, int mode);

返り値
   エラーの場合は-1を返します。




名前
   SWAP_RN() 文字列全体の中のすべての指定文字を、(\r\n)の改行に置き換える。 

書式
   char * swap_rn(char *(1), char(2));
   (1) 文字列のポインター、予め動的に確保されたものであること。
   (2) 置き換える文字。

   使用例　　　＞　　 data = swap_rn(data, 'a');

返り値
   通常は（1）を加工し、そのポインターを返します。




名前
   NULL_FREE() バッファーの使用された大きさ分だけNULLで埋める。

書式
   char * null_free(char *(1));
   (1) NULLで埋めたいバッファのポインター

   使用例      ＞     data = null_free(data);

返り値
   ポインターを返す




名前
   SELF_DELIM_GET() デリミターで区切られたデータの指定番めを取り出す、 固定バッファ用

書式
   int self_delim_get(char *(1), char *(2), char(3), int(4), int(5))
   (1) char * 元データ
   (2) char * 取り出したデータを入れるバファ（固定長）
   (3) デリミター
   (4) 何番めかの指定
   (5) 2バッファーの大きさ

   使用例      > memset(data, 0x00, 1024);
                 ret = self_delim_get(base, data, ',', 4, 1024);

説明
   上の使用例ではbase内をデリミタ(,)で区切った場合の4番めの文字列をdataに
   書き込む。書き込むバッファは固定長であり、充分な大きさを持つこと。

帰り値
   失敗した場合は-1を返す。
   終端には0x00が入る。









   ----- 以下はソケット関係の関数リファレンス -----



名前
   SOCKET_READA() ファイルディスクリプタから動的なバッファに読み込む  

書式
   int socket_reada(int(1), char *(2), int max);
   (1) int  ファイルディスクリプタ番号
   (2) char *  受け取ったデータを格納するバッファ
   (3) バッファの最大数

   使用例    >    ret =  socket_reada(sk, readdata, max);

説明
   戻り値が0の場合に読み込んだバファの終端が改行である場合に終了。

返り値
   読み込んだバッファーのサイズを返す、失敗した場合は-1を返す。
   バッファーの溢れなどは確認しない。






名前
   SOCKET_READAS() ファイルディスクリプタから動的なバッファに読み込む  (select付き)

書式
   int socket_readas(int(1), char *(2), int max, int interval, int mode);
   (1) int  ファイルディスクリプタ番号
   (2) char *  受け取ったデータを格納するバッファ
   (3) バッファの最大数
   (4) select time out　秒
   (5) 終了モード

   使用例    >    ret =  socket_reada(sk, readdata, max, interval, 0);

説明
   ただやみくもにread()と使うのなら、こちら使ってください。
   readごとにselectでfdを確認している
   mode 1 は終端に改行が有る場合に終了、それ以外は0x0d,0x0aがある場合に終了。
   intervalは上の条件を満たさずに、FDが次のデータを返さない場合の待ち時間。

返り値
   読み込んだバッファーのサイズを返す、失敗した場合は-1を返す。
   バッファーの溢れなどは確認しない。







名前
   SOCKET_READS() ファイルディスクリプタから動的なバッファに読み込む  

書式
   int socket_reads(int(1), char *(2), int(3), int(4));
   (1) int  ファイルディスクリプタ番号
   (2) char *  受け取ったデータを格納するバッファ（動的バッファ）
   (3) int  受け取るデータサイズの上限
   (4) int  ファイルディスクリプタの変化を待つ時間 (sec)

   使用例    >    ret =  socket_reads(sk, readdata, getlen, interval);

説明
   ファイルディスクリプタが変化するのを指定時間待ち、タイムアウトする。
   変化があり、読み込めた場合は動的なサイズのバッファにデータを書き込む。

返り値
   読み込んだバッファーのサイズを返す、失敗した場合やタイムアウトした場合
   は-1を返す。





名前
   SOCKET_SENDS() ファイルディスクリプタに書き込む

書式
   int socket_sends(int(1), char *(2), int(3), char(4));
   (1) int ファイルディスクリプタ番号
   (2) char * 書き込むデータの入ったバッファ
   (3) int ファイルディスクリプタの変化を待つ時間 (sec)
   (4) char 通常は0 サーバ側で使う場合は 1 を指定

   使用例     >    ret = socket_sends(sk, senddata, 5, 0);

説明
   ファイルディスクリプタに書き込み可能になるのを待って書き込む。

返り値
   書き込んだバッファーのサイズを返す。失敗した場合やタイムアウトの場合は
   -1を返す。





名前
   SOCKET_SEND() ファイルディスクリプタに書き込む

書式
   int socket_sends(int(1), char *(2), int(3));
   (1) int ファイルディスクリプタ番号
   (2) char * 書き込むデータの入ったバッファ
   (3) int ファイルディスクリプタの変化を待つ時間 (sec)

   使用例     >    ret = socket_sends(sk, senddata, 5);

説明
   ファイルディスクリプタに書き込み可能になるのを待って書き込む。

返り値
   書き込んだバッファーのサイズを返す。失敗した場合やタイムアウトの場合は
   -1を返す。





名前
   SELECT_FDCAT() ファイルディスクリプタから読み出しバファに格納

書式
   char * select_fdcat(int(1), char *(2), int *(3), int(4), int(5))
   (1) int ファイルディスクリプタ番号
   (2) char * 書き込むデータの入ったバッファ
   (3) 返却ステータスのポインターを指定する。
   (4) バファに格納する上限サイズ
   (5) select()の待ち時間(秒)

   使用例     >    data = socket_sends(sk, data, &ret, MAX, interval);

返り値
   読み出したデータを返す。






   ----- 以下はファイル操作関数リファレンス ----

名前
    FILE_COPY() ファイルをコピーする

書式
    int file_copy(char *(1), char *(2));
    (1) char * 読み込むファイル名
    (2) char * 書き込むファイル名

    使用例      >      ret = file_copy("/tmp/a.txt", "/tmp/b.txt");

説明
    読み込みファイルから読み込み、その内容をそのまま書き込みファイルにうつす。

返り値
    失敗した場合は -1 を返す。成功した場合はコピーしたバイト数を返す。




名前
   UNLINKDIR() ディレクトリー内のファイルの一括削除

書式
   int unlinkdir(char *(1));
   (1) char * ディレクトリ名

   使用例       >      ret = unlinkdir("/tmp/");

説明
   ディレクトリをオープンし、中に含まれるファイルをすべて消す。

返り値
   失敗した場合（ディレクトリが開けない場合）は-1、または開けても削除に失敗し
   たファイル数の分だけ-1していく。






   ----- 以下は低水準関数リファレンス -----



名前
   CH_INT() 文字列が数字か+,-で構成されていることを確認

書式
   int ch_int(char *(1));
   (1) チェックするバッファ

   使用例    >    ret = ch_int(data);

説明
   単純に、data 内に数字か正負記号以外が含まれた場合は-1を返し、無い場合は0を返す。

返り値
   説明に従う





名前
   CH_INT2() 文字列が数字で構成されていることを確認

書式
   int ch_int2(char *(1));
   (1) チェックするバッファ

   使用例    >    ret = ch_int2(data);

説明
   単純に、data 内に数字以外が含まれた場合は-1を返し、無い場合は0を返す。

返り値
   説明に従う






名前
   CH_INT3() 文字列が数字か任意の文字一つで構成されていることを確認

書式
   int ch_int3(char *(1), char(2));
   (1) チェックするバッファ
   (2) 文字

   使用例    >    ret = ch_int3(data, ':');

説明
   単純に、data 内に数字か任意の文字一字以外が含まれた場合は-1を返し、無い場合は0を返す。

返り値
   説明に従う





名前
   CH_INT_V6() dataがIPV6アドレスを構成する文字であることを確認

書式
   int ch_int_v6(char *(1));
   (1) チェックするバッファ

   使用例    >    ret = ch_int_v6(data);

説明
   単純に、data 内にIPV6アドレスを構成する以外の文字が含まれた場合は-1を返し、無い場合
   は0を返す。

返り値
   説明に従う






名前
   CH_INT_V4() dataがIPV4アドレスを構成する文字であることを確認

書式
   int ch_int_v4(char *(1));
   (1) チェックするバッファ

   使用例    >    ret = ch_int_v4(data);

説明
   単純に、data 内にIPV4アドレスを構成する以外の文字が含まれた場合は-1を返し、無い場合
   は0を返す。

返り値
   説明に従う







名前
   CH_CHAR() 文字列が数字かASCII文字であることを確認し、バッファーにコピーする。

書式
   int ch_char(char *(1), char *(2));
   (1) チェックするバッファ
   (2) コピー先バッファ

使用例     >      ret = ch_char(data, cpydata);

説明
   1の中に含まれる数字とASCII文字だけを2のバッファーにコピーする。
   終端に0x00を書き込む。2のバッファの大きさの確認はしないので注意。

返り値
   コピーした数を返す。一つの移らない場合は0を返す。1、2が同じなら全てコピーしたことになる。




名前
   CHAR_COUNT() 文字列に検索するキャラクタが幾つ含まれるか数える

書式
   int char_count(char *(1), char(2));
   (1) char * 検索される文字列
   (2) char 検索文字

   使用例     >    ret = char_count("123-567", '-');

説明
   例の場合、'123-567'の中に'-'が一つあるのでret=1になる。

返り値
   説明に従う





名前
   CHAR_GET() 文字列をデリミターで区切り、指定番めの文字列をバッファに入れる。

書式
   int char_get(char[](1), char[](2), char(3), int(4));
   (1) char[] 検索される文字列
   (2) char[] 取り出されたデータを入れるバッファ。サイズチェックが無いので注意。
   (3) デリミター文字
   (4) デリミターの位置番め

   使用例    >    ret = char_get("-123-456-789-", buf, '-', 2);

説明
   例の場合、文字列に'-'が表れる2番めから3番めまでの文字列'456'がbufに格納される。
   終端には0x00が入る。

返り値
   返す文字列のサイズを返す。



   

名前
   CHAR_POINT() 文字列の中で指定文字が指定番めに表れる先頭からの位置を返す。

書式
   int char_point(char *(1), char(2), int(3));
   (1) char * 検索文字列
   (2) char 検索文字
   (3) int 検索文字の位置（番め）

   使用例    >    ret = char_point("-12-345-6789-", '-', 3);

説明
   例の場合、文字列に'-'が3番めに表れる先頭からの位置は7なので7を返す。
   但し、先頭文字を0番めとして数えているので注意。

返り値
   説明に従う





名前
   CLEAN_MEM() 文字列を指定した文字で全て書き換える。

書式
   int clean_mem(char[](1), char(2), int(3));
   (1) char[] 書き換えるバッファ
   (2) char 書き換える文字
   (3) バッファのサイズ

   使用例     >    ret = clean_mem(buf, (char)0x00, (int)strlen(buf));

説明
   例の場合、bufの中を全てNULL文字でうめる。
   後端から埋めていくことに注意。

返り値
   成功した場合は0を返す。






名前
   COUNT_MEMCPY() 文字列の先頭から指定した数だけバッファにコピーする

書式
   int count_memcpy(char[](1), char[](2), int(3));
   (1) char[] コピー先のバッファ、サイズチェックなしなので注意
   (2) char[] コピー元のバッファ
   (3) int (2)の先頭からコピーするバイト数

   使用例     >   ret = count_memcpy(buf, "1234567", 3);

説明
   例の場合、bufには123の文字列がコピーされる、終端は0x00で埋められる。

返り値
   書き込んだバイト数を返す。






名前
   COUNT_MEMCPY2() 文字列の指定位置から指定した数だけバッファにコピーする

書式
   int count_memcpy(char[](1), char[](2), int(3));
   (1) char[] コピー先のバッファ、サイズチェックなしなので注意
   (2) char[] コピー元のバッファ
   (3) int 指定位置(先頭からのバイト数)
   (4) int (3)の位置からコピーするバイト数

   使用例     >   ret = count_memcpy2(buf, "1234567", 3, 6);

説明
   例の場合、bufには3456の文字列がコピーされる、終端は0x00で埋められる。

返り値
   書き込んだバイト数を返す。








名前
   DELIM_COUNT() 文字列をデリミターで区切り、指定番めの文字列の先頭位置と終端位置を返す。

書式
   int delim_count(char *(1), char(2), int(3), int *(4), int *(5));
   (1) char * 分割される文字列
   (2) char デリミター文字
   (3) int デリミターの位置番め
   (4) int * 切り出した文字列の先頭位置を返す、ポインター
   (5) int * 切り出した文字列の終端位置を返す、ポインター

   使用例     >     ret = delim_count("1-23-456-789", '-', 2, &sta, &sto);

説明
   例の場合、'-'デリミタで2こ目の文字列は456になるが、この先頭位置を終端いちを
   それぞれ&sta, &stoに返す。

返り値
   失敗した場合は-1を返す。






名前
   MEM_COUNT() 文字列に指定文字が最後に表れる場所（番め）を返す。

書式
   int mem_count(char *(1), char(2));
   (1) char * 検索文字列
   (2) char 検索文字

   使用例    >     ret = mem_count("12-345-678", '-');

説明
   例の場合、'-'が最後に表れるのは先頭から6番めで、先頭を0とする。

帰り値
   説明に従う





名前
   MEM_TCOUNT() 文字列に指定文字が最初に表れる場所（番め）を返す。

書式
   int mem_tcount(char *(1), char(2));
   (1) char * 検索文字列
   (2) char 検索文字

   使用例    >     ret = mem_tcount("12-345-678", '-');

説明
   例の場合、'-'が最初に表れるのは先頭から2番めで、先頭を0とする。

帰り値
   説明に従う






名前
   MEMCOUNT_CPM() 文字列の指定位置を別バッファにコピーする

書式
   int memcount_cpm(char *(1), char *(2), int(3), int(4), int(5));
   (1) char * コピー先のバッファ。サイズ確認なしなので注意
   (2) char * 切り出す文字列
   (3) int 切り出す先頭位置
   (4) int 切り出す終端位置
   (5) 1の大きさ

   使用例   >    ret =  memcount_cpm(buf, "0123456789", 3, 5, 8);

説明
   例の場合、先頭を0と数えるので、bufに入るのは345です。

返り値
   成功した場合はコピーした文字の数。
   失敗した場合は-1を返します。






名前
   RM_CRLF() 文字列の中の\r\nを0x00に置き換える

書式
   int rm_crlf(char *(1), int(2));
   (1) char * データ文字列
   (2) int 上限値、通常は strlen()の値

   使用例     >     int = rm_crlf(data, (int)strlen(data));

説明
   単純に改行コードをNULLに書き換えるので、文字列の途中にある場合は
   データが切断されることに注意。

返り値
   データの大きさを返します。





名前
   RM_CHAR() 文字列の中の特定の文字を消して、お尻をつめる。

書式
   int rm_char(char *(1), char(2));
   (1) char * データ文字列
   (2) char 置き換え文字

   使用例      >    ret = rm_char(data, 'd');

説明
   文字列の中に現れる指定文字を消して、後ろからその位置に詰める。
   終端には0x00が入る。

返り値
   消した文字数を返す。但しバッファーの中身が無くなった場合は0を返す。






名前
   SET_MEM() 文字列の中の特定の文字を0x00に置き換える

書式
   int set_mem(char *(1), char(2), int(3));
   (1) char * データ文字列
   (2) char 置き換え文字
   (3) int 上限値、通常はstrlen()の値

   使用例      >    ret = set_mem(data, 'd', (int)strlen(data));

説明
   特定の文字を0x00に置き換える。文字列の途中に指定文字があると、
   データはそこで切断されるので注意。

返り値
   データの大きさを返す。






名前
   SWAP_MEM() 特定の文字を特定の文字で置き換える

書式
   int swap_mem(char *(1), char(2), char(3));
   (1) char * 置き換え元の文字列
   (2) char 置き換えられる文字
   (3) char 置き換える文字

   使用例     >    ret = swap_mem(data, 'x', 'g');

説明
   例の場合、data の中の'x'を全て 'g'に置き換える。

返り値
   置き換えた数を返します。





名前
   CHMEM() とにかく指定した数だけ0x00でうめる。

書式
   int chmem(char *(1), int);
   (1) char * 置き換え元の文字列
   (2) 置き換える文字数。

   使用例     >    ret = chmem(data, 10);

説明
   とにかく指定した数だけ0x00でうめる。バッファの溢れは考慮しない。

返り値
   2に対して、0より少ない数を指定すると-1を返す。








   ----- 以下は特殊用途関数 -----

名前
   BASE64() 文字列をbase64エンコードする。

書式
   int base64(char[](1), int(2), char[](3));
   (1) エンコード前の文字列
   (2) エンコード前の文字列の大きさ
   (3) エンコード後の文字列の入れ先

   使用例　　＞   base64(a, (int)strlen(a), b);

説明
   上の場合aを64エンコードしてbに入れる。bの大きさは最低でもaの倍ないといけない。

返り値
   現状で0しか返さない。





名前
   UJTOJ() EUC文字列をJISに変更する。

書式
   int ujtoj(unsigned char *(1), unsigned char *(2));
   (1) 戻りバファ、JISに変換後。
   (2) EUCのバファ。


   使用例　　＞   ujtoj((unsigned char *)out, (unsigned char *)in);

説明
   上の場合in(EUC)をout(JIS)に変換します。
   この関数は 「TCP_IP ネットワークプログラミング」から使わせていただいてます。

返り値
   現状で0しか返さない。





名前
   SAFE_BASE64() 文字列をbase64エンコードする。 (動的バッファ)

書式
   char * safe_base64(char *(1));
   (1) エンコードしたいバッファ。領域を予め動的に確保していること。

   使用例　　　＞　　data = safe_base64(data);

説明
   予め動的に確保されたバッファにエンコードしたい文字列を入れsafe_base64()に渡すと、
   同じバッファにbase64エンコードされた文字列を返します。
   このバッファは最大で渡した文字列の倍のサイズに動的に拡張されることに注意。

返り値
   バッファのポインターを返します。






名前
   SAFE_UJTOJ() EUC文字列をJISに変更する。(動的バッファ)

書式
   char * safe_ujtoj(char *(1));
   (1) 変換したいバファ、(EUC をJISに変換)

   使用例　　＞   data = safe_ujtoj(data);

説明
   上の場合data (EUC)をdata(JIS)に変換します。

返り値
   バッファのポインターを返します。






名前
   MIME_UJTOJ() EUC文字列をJISに変換しながら、76文字で折り返しMIMEに従ったsubject文字に変更する。（動的バッファ）

書式
   char * mime_ujtoj(char *(1));
   (1) EUC文字列バッファ。領域を予め動的に確保していること。

   使用例　　＞　　data = mime_ujtoj(data);

説明
   上記の場合、EUC文字列をJISに変換しながら、76文字で折り返しMIMEに従ったsubject文字に変更した値を返す。

返り値
   バッファのポインターを返します。





名前
   RANDDATA() 指定した数字の幅の中から、マイクロ秒をseedとして生成した乱数を返す。

書式
   int * randdata(int (1), int (2));
   (1) 生成する乱数の下限
   (2) 生成するランスの上限

   使用例　　＞　　randint = randdata(0, 10);

説明
   上記の場合、0から10の間の数字のいずれかをマイクロ秒を種として出した乱数の値で返す。

返り値
   乱数を返す。












   ----- 以下は時間関係の関数リファレンス -----



名前
   CHAR_WDAY() 0から6の数字から3文字の曜日を示す文字列をかえす。

書式
   char * char_wday(int (1));
   (1) int 0から6の数字。以下は数字が示す曜日、また戻す文字列
           0: 日曜    Sun
           1: 月曜    Mon
           2: 火曜    Tue
           3: 水曜    Wed
           4: 木曜    Thu
           5: 金曜    Fri
           6: 土曜    Sat
        意外:         Not!
 
   使用例       >       char * cha = char_wday(0);

説明
   例の場合、'Sun' という文字列がかえされる。

返り値
   意外の数字を与えた場合は'Not!'が返される。







名前
   CHAR_MON()  0から11の数字から3文字の月を示す文字列をかえす。

書式
   char * char_mon(int (1));
   (1) int 0から11の数字。以下は数字が示す月、また戻す文字列
           0: 1月  Jan
           1: 2月  Feb
           2: 3月  Mar
           3: 4月  Apr
           4: 5月  May
           5: 6月  Jun
           6: 7月  Jul
           7: 8月  Aug
           8: 9月  Sep
           9: 9月  Oct
          10: 10月 Nov
          11: 11月 Dec
          12: 12月 Dec
        意外:      Not!

   使用例       >       char * mon = char_mon(0);

説明
   例の場合、'Jan' という文字列がかえされる。

返り値
   意外の数字を与えた場合は'Not!'が返される。





名前
   UTIME_GETR() unix time からcharで指定した時間をかえす

書式
   int utime_getr(time_t(1), char(2));
   (1) 指定unix time 
   (2) 文字。以下は文字が示す属性
       'y': 年
       'm': 月
       'd': 日
       'w': 曜日(0 - 6 CHAR_WDAY() を参照)
       'h': 時
       'i': 分
       's': 秒
      意外:  0 をかえす 

   使用例       >       int day = char_mon((time_t)lin, 'd');

説明
   例の場合、lin という数字をUNIX TIMEに置き換えて、その時の日日を計算して整数でかえす

返り値
   意外の数字を与えた場合は0が返される。






名前
   CTIME_GETR() 現在時刻の指定文字の示す時間属性をかえす */

書式
   int ctime_getr(char (1))
   (1) 文字。以下は文字が示す属性
       'y': 年
       'm': 月
       'd': 日
       'w': 曜日(0 - 6 CHAR_WDAY() を参照)
       'h': 時
       'i': 分
       's': 秒
      意外:  0 をかえす 

   使用例       >       int day = ctime_getr('d');

説明
   例の場合、現在時刻の日日を整数でかえす
   この関数はスレッドセーフである

返り値
   意外の数字を与えた場合は0が返される。






名前
   TIME_MINUS() cha 単位で t 時 から mt 時間引いた時間を返す関数 0 - 1 = 23

書式
   int time_minus(int t(1), int mt(2), char cha(3))
   (1) 引かれる時間
   (2) 引く時間
   (3) 文字。以下は文字が示す属性
       'h': 時 24 単位
       'i': 分 60 単位
      意外:    12 単位とする

   使用例       >       int ha = time_minus(0, 1, 'h');

説明
   例の場合、0時から1時間引いた場合の時間の23時が返る
   時間と分に対してしか使えない。 

返り値
   意外の数字を与えた場合は0が返される。







名前
   GET_UNIXTIME() localな時間からUNIX時間をかえす。

書式
   time_t get_unixtime(int ye(1), int mo(2), int day(3), int hour(4), int min(5), int sec(6))
   (1) 年 (例1970)
   (2) 月
   (3) 日
   (4) 時間
   (5) 分
   (6) 秒
   これらは0以下の場合は0に修正される

   使用例       >      time_t tt = get_unixtime(1970, 1, 1, 1, 1, 1)

説明
   例の場合のtt は0になるはずである

返り値
   意外の数字を与えた場合は0が返される。




名前
   MESSAGE_ID() 出きるだけユニークなメッセージIDを作ります。

書式
  char * message_id(char *(1), char *(2), char *(3));
  (1) データを戻したいバッファ、戻り値と同じポインターを指定、予めmallocされていること。
  (2) ＠の前に入れたい名前
  (3) ＠の後に入るドメイン

  使用例   retp = message_id(retp, "taro", "zither.ms-n.com");

説明
  出力フォーマットは年月日時分.ランダムな数字.名前＠ドメイン名

返り値
  ポインターのアドレス。





名前
   DAY_MINUS()  現在の年月で、一日前の日をかえす。(1 - 1 = 31)

書式
   int day_minus(int(1))
   (1) この日日から1を引いた日が返る

   使用例       >       int a = day_minus(31);

説明
   例の場合、 aには0日が入るかもしれない
   うるう年や月が28日か30、31なのかの判断は現在の月から判断する。

返り値
   異常の場合は-1が返る。







名前
   MONTH_LAST() 何年何月の最後の日を出す

書式
   int month_last(int(1), int(2));
   (1) 年(例2008)
   (2) 月(例1)

   使用例         >      int mo = month_last(2008, 1);

説明
   例の場合、moには2008年1月の最後の日である31が返る。うるう年も考慮される。

返り値
   異常の場合は-1が返る








名前
   MONTH_MINUS()  指定月から一ヶ月引いた月をかえす。単純。。。

書式
   int month_minus(int(1))
   (1) 月(1 - 12)

   使用例          >      int month_minus(1);

説明
   例の場合、1月の前の月は12月なので12が返る。

返り値
   異常の場合は-1が返る








名前
   TIME_GETR() 現在時刻の:区切りの文字列をバッファにかえす。

書式
   char * time_getr(char *(1));
   (1) 文字列を返すバッファのポインター

   使用例         >       char * data = time_getr(data);

説明
   例の場合、data に 2007:09:28:02:22:59 のような文字列が入る。
   data は予め動的に確保されている必要がある。

返り値
   失敗の場合は不明です。




